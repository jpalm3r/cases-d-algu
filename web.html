<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>web</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="web_files/libs/clipboard/clipboard.min.js"></script>
<script src="web_files/libs/quarto-html/quarto.js"></script>
<script src="web_files/libs/quarto-html/popper.min.js"></script>
<script src="web_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="web_files/libs/quarto-html/anchor.min.js"></script>
<link href="web_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="web_files/libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="web_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="web_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="web_files/libs/bootstrap/bootstrap-9441826061aba80df401c9bee89e68bb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p><br></p>
<font size="90">
<center>
<b>CASES D’ALGÚ</b>
</center>
</font><p><font size="90"></font></p>
<div style="text-align: right">
<b>➫ Autor:</b> Jaume Palmer
</div>
<div style="text-align: right">
(Setembre 2022)
</div>
<p>Aquest projecte pretén visualitzar la distribució de places turístiques a Mallorca.</p>
<p>La inspiració del projecte neix com a combinació entre una indignació post-estival i aquest <a href="https://twitter.com/terraferida/status/1566781070883930114?s=12&amp;t=tH5yHxOBZJd_qUAKgLVHoA">tuit de n’Aina Ginard</a> que mostra xifres de com es reparteixen les places turístiques pels diferents municipis. En el seu estudi, n’Aina subratlla que <strong>a Mallorca s’ofereixen 45 places turístiques per cada 100 habitants</strong>. El meu objectiu ha estat endinsar-me una mica més en el que s’amaga darrere aquesta xifra.</p>
<p><br></p>
<p>Les 45 places han estat calculades tenint en compte la població total de l’illa, així com les places turístiques de tot el territori. Per començar, basta posar el focus als municipis per veure que algunes zones ja superen (de molt) la mitjana de l’illa:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./figs/figure_vp100p.png" class="img-fluid figure-img"></p>
<figcaption>places100persones</figcaption>
</figure>
</div>
<p>Poblacions com Sant Llorenç o Ses Salines mostren valors extrems donada la poca gent censada (~600 i ~900 persones respectivament). Tot i així, altres municipis més poblats com Alcúdia o Calvià mostren valors per damunt les 100 places turístiques per 100 habitant.</p>
<p>Per entendre millor la relació entre el nombre de places en un municipi i la seva població, val la pena tornar al mapa de l’illa:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./figs/choros_transparent.png" class="img-fluid figure-img"></p>
<figcaption>choropleth</figcaption>
</figure>
</div>
<ul>
<li><p>El mapa de l’esquerra mostra (tal com va fer el tuit original) la distribució de places turístiques al territori. Es veu clarament com la oferta es concentren al litoral de l’illa.</p></li>
<li><p>El mapa de la dreta mostra com es reparteix la població als diferents municipis. Aquest mapa mostra com les àrees més densament poblades estan a l’interior de l’illa, concretament en els municipis que connecten Palma amb Alcúdia.</p></li>
</ul>
<p>El contrast entre els mapes és facil de veure. Tret d’alguna excepció, els municipis més densament poblats son precisament els que tenen menys concentració de places turístiques.</p>
<p>Com que la densitat de població i places varia tant al voltant del territori, he volgut dividir l’illa en regions més facils de comparar. Per aixo m’he centrat en les diferents regions de Mallorca, així com en la diferència entre municipis de costa i interior. Finalment, en comptes de fixar-me en el total de places turístiques, he separat entre les <font color="#ff7d00">places d’hotel</font> i <font color="#15616d">places de lloguer vacacional</font>.</p>
<p>La seguent gràfica mostra la distribució de places en cada una d’aquestes regions. Cada municipi esta representat per dos punts, com assenyalo amb l’exemple de Muro: el punt <font color="#ff7d00">taronja</font> assenyala les places hotelers del municipi i el punt <font color="#15616d">blau</font> les seves places de lloguer.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./figs/figure_punts_web.png" class="img-fluid figure-img"></p>
<figcaption>punts</figcaption>
</figure>
</div>
<p>Es pot veure com a les regions del Pla i el Raiguer, els punts es concentren a la part baixa de la gràfica. Concretament, ambdues regions mostren poca concentració de places d’hotel, a excecpció de Muro, Alcúdia i Santa Margalida. Les places de lloguer es situen lleugerament per sobre de les places d’hotel. En canvi, a Tramuntana tots els punts es reparteixen de manera uniforme fins arribar a valors que ronden les 100 places d’hotel i de lloguer turístic per cada 100 habitants.</p>
<p>La gràfica de la dreta mostra la diferència entre els municipis de costa i d’interior. A la costa, les places turístiques s’estiren fins a arribar a valors extrems, mentre que a l’interior els punts es concentren a la part baixa de la gràfica. De fet, aquesta divisió permet veure com a l’interior s’hi troben més places de lloguer que d’hotel.</p>
<p>Per acabar, es poden resumir els resultats en la seguent taula:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Llevant</th>
<th>Migjorn</th>
<th>Palma</th>
<th>Pla</th>
<th>Raiguer</th>
<th>Tramuntana</th>
<th></th>
<th></th>
<th></th>
<th>Costa</th>
<th>Interior</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Places hotel per 100 hab.</td>
<td>95.1</td>
<td>51.5</td>
<td>12.0</td>
<td>52.1</td>
<td>20.5</td>
<td>69.3</td>
<td></td>
<td></td>
<td></td>
<td>42.0</td>
<td>2.0</td>
</tr>
<tr class="even">
<td>Places lloguer vac. per 100 hab.</td>
<td>21.8</td>
<td>27.4</td>
<td>1.0</td>
<td>21.7</td>
<td>13.2</td>
<td>24.4</td>
<td></td>
<td></td>
<td></td>
<td>11.6</td>
<td>11.2</td>
</tr>
<tr class="odd">
<td><strong>Places turístiques per 100 hab.</strong></td>
<td>116.9</td>
<td>78.9</td>
<td>13.0</td>
<td>73.8</td>
<td>33.7</td>
<td>93.7</td>
<td></td>
<td></td>
<td></td>
<td>53.6</td>
<td>13.2</td>
</tr>
</tbody>
</table>
<p>Només Palma i el Raiguer estan per davall de la mitjana de l’illa (~45 places turístiques per 100 habitants). Destaca l’explotació a la serra de Tramuntana: sense presentar valors extrems que distorsionen la mitjana s’arriba al valor de 94 places per cada 100 habitants.</p>
<p>Com era d’esperar, si dividim l’illa entre costa i interior, trobem molta més concentració turística a la costa. La diferència la marca la presencia d’hotels donat que les places de lloguer vacacional son molt similars.</p>
<hr>
<div style="text-align: right">
(En cas de voler més detalls, aquí es poden trobar <a href="https://github.com/jpalm3r/cases-d-algu">les dades i el codi</a>).
</div>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>